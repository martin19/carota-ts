<!DOCTYPE html>
<html>
<head>
  <title></title>
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.22/require.min.js"></script>
  <style>
    #exampleEditor {
      border: 1px solid silver;
      position: absolute;
      left: 10px;
      top: 40px;
      right: 50%;
      bottom: 40px;
    }

    #exampleCanvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 800px;
      height: 800px;
      background-color: wheat;
    }

    #examplePersistence {
      position: absolute;
      top: 40px;
      width: 50%;
      right: 0;
      bottom: 40px;
    }

    #examplePersistence div {
      position: absolute;
      left: 10px;
      top: 0;
      right: 10px;
      bottom: 0;
      overflow: hidden;
    }

    #examplePersistence textarea {
      width: 99%;
      height: 99%;
      border: none;
      background: rgb(30, 30, 30);
      color: rgb(0, 200, 20);
    }

    button img {
      width: 12px;
      height: 12px;
    }

    .editablePage {
      display: none
    }
  </style>
</head>
<body>


<div id="exampleEditor">
  <canvas id="exampleCanvas" width="800" height="800"></canvas>
</div>

<div id="examplePersistence">
  <div>
    <textarea></textarea>
  </div>
</div>

<div class="editablePage" id="welcome">
  <h1>Welcome!</h1>
  <br>
  <p>You've found the demo page for <span class="carota">Carota</span>, a rich text editor
    implemented entirely in JavaScript that uses HTML5 Canvas for rendering. Most in-browser
    editors use a built-in feature called <code>contentEditable</code> to do most of the
    hard work, but this has some limitations and drawbacks that are just too much for more
    sensitive people, like me, to bear, so I decided to start from scratch.
    (Anyway, it's fun to write your own editor!)
  </p>
  <br>
  <p>The source code is released under the very permissive <strong>MIT license</strong>,
    so you can do pretty much anything you want with it.
  </p>
  <br>
  <p>At runtime Carota has <em>no external dependencies</em>. You just pull in the
    carota-min.js file using the SCRIPT tag and away you go. Or else get node and use:
  </p>
  <br>
  <p>
    <code>npm install carota</code>
  </p>
  <br>
  <p>to get the full source, including this demo site. By the way,
    <span class="carota">Carota</span> itself is displaying all this text, meaning that
    you can play with the editor right now! Try <code>Ctrl+A</code> and then
    <code>Backspace</code> to clear this document and see how the JSON view on the right
    changes as you make further edits. Press <code>Ctrl+Z</code> to undo your changes.
  </p>
  <br>
  <p><strong>Click the links below for more information...</strong>
  <p>
  </p>
</div>

<div class="editablePage" id="why">
  <h1>Why might you need this?</h1>
  <br>
  <p>For many people's needs, the <code>contentEditable</code> attribute in modern browsers is
    quite adequate. But if you need more control over rich text editing it is sadly a dead
    end.</p>
  <br>
  <p>The word processor in <b>Google Docs</b> does not use
    <code>contentEditable</code>.
    Nor does <b>Apple's Pages in iCloud</b>. Instead they have their own JavaScript-based
    rich text rendering and editing code. Sadly they are not open source licensed!
  </p>
  <br>
  <p>In some ways, <code>contentEditable</code> is too powerful. It allows your users to edit
    every possible feature of HTML implemented by the browser. I often find that I only want
    to support a simple form of rich text that is totally under my control. And the API for
    representing a range within the text is quite complex because it has to deal with the
    tree-like nature of the DOM. I wish there was a simple way to work in pure character
    positions (i.e. mere integers).
  </p>
  <br>
  <p>In other ways, <code>contentEditable</code> is frustratingly inadequate. There are built-in
    commands for applying formatting changes to the current selection, but they <em>suck</em>,
    especially setting the font size. There are bugs and quirks that vary between browsers.
    Taming <code>contentEditable</code> can become a full-time job in itself.
  </p>
  <br>
  <p>Bear in mind that <span class="carota">Carota</span> does not implement all the same
    features as HTML's <code>contentEditable</code>. If you're okay with the limitations of
    <code>contentEditable</code> then by all means you should stick with it.
  </p>
</div>

<div class="editablePage" id="how">
  <h1>How does it work?</h1>
  <br>
  <p>Several representations of text play a part in <span class="carota">Carota</span>.</p>
  <br>
  <p><b>JSON</b> is the cornerstone of persistence in JavaScript. It is used here to
    represent rich text, which is just an array of objects. Each object is called a
    <i>run</i>, and has a property called <code>text</code> and various other optional
    properties to specify the formatting for the text in the run. The text can include
    inline objects of your own invention, which you can tell
    <span class="carota">Carota</span> how to represent. (That's how the smiley icons
    work in this demo - try inserting one!)
  </p>
  <br>
  <p><b>Characters</b> are objects representing the characters in the text as a single
    continuous stream of objects. This is an abstraction over the JSON format to make
    it easy to split the text into words. An inline object acts like a single character.
  </p>
  <br>
  <p><b>Words</b> are objects representing the words in the text, the output of the
    word-breaking process. A word has two parts: the non-space characters, and the
    trailing space characters. Either part may be empty, but not both. (A new line is
    always emitted as a separate word.) Of course, a word can contain regions of the
    text with different formatting. All edits to the document involve modifying the
    list of words. Words store their own dimensions (<code>width</code>,
    <code>ascent</code> and <code>descent</code>).
  </p>
  <br>
  <p><b>Static</b> representation is the result of word-wrapping. Every time the word
    list is modified, wrapping must be performed, but it's pretty fast because we
    already know the dimensions of each word. The static representation is a list
    of <code>Line</code> objects, and each line contains a list of
    <code>PositionedWord</code> objects, each of which contains a list of
    <code>PositionedCharacter</code> objects. These objects form a uniform hierarchy
    of nodes, and at the root is the <code>Document</code>. Everything is already
    positioned, so drawing to the canvas is fast, and implementing the editor is
    pretty easy. Also any custom inline objects are converted into handlers that
    know how to render them.
  </p>
  <br>
  <p>Those are the main core representations involved. In addition a subset of
    <b>HTML</b> can be loaded into the editor via a parser that converts it into the
    native JSON format.
  </p>
</div>

<div class="editablePage" id="usage">
  <h1>How to use it</h1>
  <br>
  <p>First, the bad news: if you need to support IE8 and earlier, then
    <span class="carota">Carota</span> is not for you. Right now it requires
    Canvas. It may be extended in the future to support other ways of rendering.</p>
  <br>
  <p>This demo page has been deliberately set up to make it easy to learn from,
    the old fashioned way: using the <em>View source</em> command. Everything is
    in a single index.html file.</p>
  <br>
  <p>It begins with some basic CSS styling, mostly for positioning. Then there
    is the HTML, most of which is for the "toolbar". <span class="carota">Carota</span>
    does not have a built-in toolbar, but it's very easy to wire up your own
    controls to it. This page does it in about 30 lines of code.</p>
  <br>
  <p>The text for these pages is held in some hidden DIVs, which get parsed
    into the native JSON format and then loaded into the editor.</p>
  <br>
  <p>Finally there is a PRE element that displays the JSON saved from the editor,
    every time you make an edit.</p>
  <br>
  <p>The parts of the code that interact with <span class="carota">Carota</span>
    (there isn't much) works by calling <code>carota.editor.create</code> to cause the
    editor to be created. Then methods are called on the resulting object to
    <code>load</code> this text, to subscribe to events (<code>selectionChanged</code>,
    <code>contentChanged</code>), to <code>performUndo</code> (and discover if we
    <code>canUndo</code>), to query or modify the <code>selectedRange</code> and to
    <code>insert</code> inline elements (the smiley button).</p>

  <br>
  <p>There are also a handful of calls to functions in <code>carota.dom</code> which
    is just a very minimal helper library for conveniently wiring up events, etc. In
    your own code you'll probably want to use a more full-featured alternative like
    jQuery, etc. <span class="carota">Carota</span> deliberately avoids depending on
    any such general DOM-manipulation library so it can integrate with anything.
  </p>

</div>

<script>
  window.onload = function () {
    require.config({
      baseUrl: './src'
    });
    require(["carota"], function (carota) {
      carota = carota.carota;

      var canvas = document.querySelector("#exampleCanvas");
      var editor = new carota.Editor({
        canvas: canvas,
        x : 400,
        y : 400,
        w : 400,
        h : 500
      });
      var exampleEditor = editor.getDoc();

      window.editor = editor;

      // Setting up the button so user can insert a smiley
      /*carota.Dom.handleEvent(document.querySelector('#smiley'), 'click', function () {
       exampleEditor.insert({smiley: true});
       });*/

      // We don't update the JSON view until half a second after the last change
      // to avoid slowing things down too much
      var persistenceTextArea = document.querySelector('#examplePersistence textarea');
      var updateTimer = null;
      var updatePersistenceView = function () {
        if (updateTimer !== null) {
          clearTimeout(updateTimer);
        }
        updateTimer = setTimeout(function () {
          updateTimer = null;
          persistenceTextArea.value = JSON.stringify(exampleEditor.save(), null, 4);
        }, 500);
      };

      var manuallyChangingJson = 0;
      carota.Dom.handleEvent(persistenceTextArea, 'input', function () {
        try {
          manuallyChangingJson++;
          exampleEditor.load(JSON.parse(persistenceTextArea.value), false);
        } catch (x) {
          // ignore if syntax errors
        } finally {
          manuallyChangingJson--;
        }
      });

      // Whenever the document changes, re-display the JSON format and update undo buttons
      exampleEditor.contentChanged.on(function () {
        TextBoxController.updateUndo();
        if (!manuallyChangingJson) {
          updatePersistenceView();
        }
      });

      // Load one of the hidden chunks of HTML
      var load = function (selector) {
        var html = document.querySelector(selector);
        if (html) {
          var paragraphs = carota.Html.parse(html, {
            carota: {color: 'orange', bold: true, size: 14}
          });
          console.log(paragraphs);
          exampleEditor.load(paragraphs);
        }
      };

//      var load = function() {
//        $.getJSON("./src/import/enginedata_area.json", function(engineData) {
//          var runs = carota.EngineData.parse(engineData);
//          exampleEditor.load(runs);
//        });
//      };

      //dat.gui
      var TextBoxController = {
        init() {
          var textBoxOptions = {
            font: "serif",
            size: 8,
            letterSpacing : 0.1,
            verticalScaling : 1.0,
            horizontalScaling : 1.0,
            lineHeight : -1,
            bold: false,
            italic: false,
            underline: false,
            strikeout: false,
            script: "normal",
            color: "black",
            undo: function () {
              exampleEditor.performUndo(false);
            },
            redo: function () {
              exampleEditor.performUndo(true);
            },
            wrap : true,
            origin : "center",
            baselines : false
          };

          var gui = new dat.GUI();

          var f1 = gui.addFolder("Character");
          var cOrigin = f1.add(textBoxOptions, "origin", ["topleft","center","bottomright"]);
          var cWrap = f1.add(textBoxOptions, "wrap");
          var cBaselines = f1.add(textBoxOptions,"baselines");
          var cFormatting = [];
          cFormatting.push(f1.add(textBoxOptions, "font", ["serif", "sans-serif", "monospace", "cursive", "fantasy"]).listen());
          cFormatting.push(f1.add(textBoxOptions, "size", [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 30, 36, 72]).listen());
          cFormatting.push(f1.add(textBoxOptions, "letterSpacing").min(-0.2).max(0.2).listen());
          cFormatting.push(f1.add(textBoxOptions, "verticalScaling").min(0).max(10).listen());
          cFormatting.push(f1.add(textBoxOptions, "horizontalScaling").min(0).max(10).listen());
          cFormatting.push(f1.add(textBoxOptions, "lineHeight").min(-1).max(100).listen());
          cFormatting.push(f1.add(textBoxOptions, "bold").listen());
          cFormatting.push(f1.add(textBoxOptions, "italic").listen());
          cFormatting.push(f1.add(textBoxOptions, "underline").listen());
          cFormatting.push(f1.add(textBoxOptions, "strikeout").listen());
          cFormatting.push(f1.add(textBoxOptions, "script", ["normal", "super", "sub"]).listen());
          cFormatting.push(f1.add(textBoxOptions, "color", ["black", "red", "green", "blue", "orange"]).listen());
          cFormatting.forEach(function (c) {
            c.onFinishChange(function (value) {
              var range = exampleEditor.selectedRange();
              range.setCharacterFormatting(this.property, value);
            });
          });
          cWrap.onFinishChange(function(value) {
            exampleEditor.setWrap(value);
          });
          cOrigin.onFinishChange(function(value) {
            switch(value) {
              case "topleft" : editor.setOrigin(-0.5,-0.5); break;
              case "center" : editor.setOrigin(0,0); break;
              case "bottomright" : editor.setOrigin(0.5,0.5); break;
            }
          });
          cBaselines.onFinishChange(function(value) {
            editor.setPaintBaselines(value);
          });

          var paragraphOptions = {
            align: "left",
            marginLeft : 0,
            marginRight : 0,
            spaceBefore : 0,
            spaceAfter : 0,
            hyphenate : false
          };

          var f2 = gui.addFolder("Paragraph");
          var cParagraph = [];
          var optionAlign = f2.add(paragraphOptions, "align", ["left","center","right","justifyLastLeft","justifyLastCentered","justifyLastRight","justifyAll"]);
          cParagraph.push(optionAlign.listen());
          cParagraph.push(f2.add(paragraphOptions,"marginLeft").min(-50).max(50).listen());
          cParagraph.push(f2.add(paragraphOptions,"marginRight").min(-50).max(50).listen());
          cParagraph.push(f2.add(paragraphOptions,"spaceBefore").min(-50).max(50).listen());
          cParagraph.push(f2.add(paragraphOptions,"spaceAfter").min(-50).max(50).listen());
          cParagraph.push(f2.add(paragraphOptions,"hyphenate").listen());

          cParagraph.forEach(function(c){
            c.onFinishChange(function(value){
              var range = exampleEditor.selectedRange();
              range.setParagraphFormatting(this.property, value);
            });
          });

          var f3 = gui.addFolder("Undo/Redo");
          f3.add(textBoxOptions, "undo");
          f3.add(textBoxOptions, "redo");

          // When the selected range coordinates change, update the control
          exampleEditor.selectionChanged.on(function (data) {
            //set CharacterFormatting UI
            cFormatting.forEach(function(c){
              var id = c.property;
              var formatting = data.getFormatting();
              var val = id in formatting ? formatting[id] : carota.Run.defaultFormatting[id];
              if(val === carota.Run.multipleValues) {
                //indeterminate
              }
              textBoxOptions[id] = val;
            });
            //set ParagraphFormatting UI
            cParagraph.forEach(function(c){
              var id=c.property;
              var range = exampleEditor.selectedRange();
              var formatting = range.getParagraphFormatting();
              var val = id in formatting ? formatting[id] : carota.Paragraph.defaultFormatting[id];
              if(val === carota.Paragraph.multipleValues) {
                //indeterminate
              }
              paragraphOptions[id] = val;
            });
          });

          var textBoxPosition = {
            cx : 100,
            cy : 100,
            alpha : 0,
            w : 100,
            h : 100,
            sx : 1.0,
            sy : 1.0
          };

          var gui2 = new dat.GUI();
          var f4 = gui2.addFolder("Position");
          var cCx = f4.add(textBoxPosition,"cx").min(0).max(500);
          var cCy = f4.add(textBoxPosition,"cy").min(0).max(500);
          var cAlpha = f4.add(textBoxPosition,"alpha").min(0).max(Math.PI*2);
          var cW = f4.add(textBoxPosition,"w").min(0).max(500);
          var cH = f4.add(textBoxPosition,"h").min(0).max(500);
          var cSx = f4.add(textBoxPosition,"sx").min(-5).max(5);
          var cSy = f4.add(textBoxPosition,"sy").min(-5).max(5);

          cCx.onChange(function(value){
            editor.setPosition(value, editor.getPosition().y);
          });
          cCy.onChange(function(value){
            editor.setPosition(editor.getPosition().x, value);
          });
          cAlpha.onChange(function(value){
            editor.setRotation(value)
          });
          cW.onChange(function(value){
            editor.setSize(value, editor.getSize().h);
          });
          cH.onChange(function(value){
            editor.setSize(editor.getSize().w, value);
          });
          cSx.onChange(function(value){
            editor.setScale(value, editor.getScale().y);
          });
          cSy.onChange(function(value){
            editor.setScale(editor.getScale().x, value);
          });

          //f1.open();
          //f2.open();
          //f4.open();
        },
        updateUndo: function () {
          //undo.disabled = !exampleEditor.canUndo(false);
          //redo.disabled = !exampleEditor.canUndo(true);
        }
      };
      TextBoxController.init();

      load('#welcome');
    });
  };
</script>
</body>
</html>
